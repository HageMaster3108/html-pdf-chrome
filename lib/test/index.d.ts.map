{"version":3,"sources":["test/index.ts"],"names":[],"mappings":"","file":"index.d.ts","sourcesContent":["'use strict';\n\n// tslint:disable:no-unused-expression\n\nimport * as chai from 'chai';\nimport * as chromeLauncher from 'chrome-launcher';\nimport * as fs from 'fs';\nimport getPort = require('get-port');\nimport * as mockFs from 'mock-fs';\nimport * as path from 'path';\nimport * as PDFParser from 'pdf2json';\nimport * as sinon from 'sinon';\nimport { Readable } from 'stream';\n\nimport * as HtmlPdf from '../src';\nimport ConsoleAPICalled from '../src/typings/chrome/Runtime/ConsoleAPICalled';\nimport ExceptionThrown from '../src/typings/chrome/Runtime/ExceptionThrown';\n\n// tslint:disable:no-var-requires\nchai.use(require('chai-string'));\nchai.use(require('sinon-chai'));\n// tslint:enable:no-var-requires\nconst expect = chai.expect;\n\ndescribe('HtmlPdf', () => {\n\n  describe('create', () => {\n    let port: number;\n    let chrome: chromeLauncher.LaunchedChrome;\n\n    before(async () => {\n      // Start Chrome and wait for it to start listening for connections.\n      chrome = await chromeLauncher.launch({\n        chromeFlags: [\n          '--disable-gpu',\n          '--headless',\n        ],\n        // uncomment if using Chrome Beta\n        // chromePath: '/usr/bin/google-chrome-beta',\n        connectionPollInterval: 250,\n        logLevel: 'error',\n        maxConnectionRetries: 50,\n      });\n      port = chrome.port;\n    });\n\n    after(async () => {\n      await chrome.kill();\n    });\n\n    it('should spawn Chrome and generate a PDF', async () => {\n      const result = await HtmlPdf.create('<p>hello!</p>');\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n    });\n\n    it('should handle a Chrome launch failure', async () => {\n      const error = new Error('failed!');\n      const launchStub = sinon.stub(chromeLauncher, 'launch').callsFake(() => Promise.reject(error));\n      try {\n        await HtmlPdf.create('<p>hello!</p>');\n        expect.fail();\n      } catch (err) {\n        expect(err).to.equal(error);\n      } finally {\n        launchStub.restore();\n      }\n    });\n\n    it('should use running Chrome to generate a PDF (specify port)', async () => {\n      const launchStub = sinon.stub(chromeLauncher, 'launch');\n      try {\n        const result = await HtmlPdf.create('<p>hello!</p>', {port});\n        expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n        expect(launchStub).to.not.have.been.called;\n        const pdf = await getParsedPdf(result.toBuffer());\n        expect(pdf.getRawTextContent()).to.startWith('hello!');\n      } finally {\n        launchStub.restore();\n      }\n    });\n\n    it('should use running Chrome to generate a PDF (specify host and port)', async () => {\n      const launchStub = sinon.stub(chromeLauncher, 'launch');\n      try {\n        const result = await HtmlPdf.create('<p>hello!</p>', {host: 'localhost', port});\n        expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n        expect(launchStub).to.not.have.been.called;\n        const pdf = await getParsedPdf(result.toBuffer());\n        expect(pdf.getRawTextContent()).to.startWith('hello!');\n      } finally {\n        launchStub.restore();\n      }\n    });\n\n    it('should generate a PDF with Chrome options', async () => {\n      const options: HtmlPdf.CreateOptions = {\n        port,\n        clearCache: true,\n        printOptions: {\n          landscape: true,\n          displayHeaderFooter: true,\n        },\n      };\n      const result = await HtmlPdf.create('<p>hello!</p>', options);\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n    });\n\n    it('should generate a PDF with cookies', async () => {\n      const options: HtmlPdf.CreateOptions = {\n        port,\n        cookies: [\n          {\n            name: 'status',\n            value: 'Passed!',\n            domain: 'westy92.github.io',\n          },\n        ],\n      };\n      const result = await HtmlPdf.create('https://westy92.github.io/html-pdf-chrome/test/cookie.html', options);\n      const pdf = await getParsedPdf(result.toBuffer());\n      expect(pdf.getRawTextContent()).to.startWith('Cookies:status=Passed!');\n    });\n\n    it('should generate a PDF and send extra HTTP headers', async () => {\n      const options: HtmlPdf.CreateOptions = {\n        port,\n        extraHTTPHeaders: {\n          'Authorization': 'Bearer',\n          'X-Custom-Test-Header': 'Passed1!',\n        },\n      };\n\n      const result = await HtmlPdf.create('https://httpbin.org/headers', options);\n      const pdf = await getParsedPdf(result.toBuffer());\n      const rawTextContent = pdf.getRawTextContent();\n\n      expect(rawTextContent).to.contain('Authorization').and.to.contain('Bearer');\n      expect(rawTextContent).to.contain('X-Custom-Test-Header').and.to.contain('Passed1!');\n    });\n\n    it('should proxy console messages', async () => {\n      const events: ConsoleAPICalled[] = [];\n      const options: HtmlPdf.CreateOptions = {\n        port,\n        runtimeConsoleHandler: (event: ConsoleAPICalled) => events.push(event),\n      };\n      const html = `\n        <html>\n          <body>\n            <script>\n              console.log('a');\n              console.warn({b: 5});\n            </script>\n          </body>\n        </html>\n      `;\n      const result = await HtmlPdf.create(html, options);\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n      expect(events.length).to.equal(2);\n      expect(events[0]).to.have.property('type', 'log');\n      expect(events[0]).to.have.deep.property('args', [ { type: 'string', value: 'a' } ]);\n      expect(events[1]).to.have.property('type', 'warning');\n    });\n\n    it('should proxy unhandled exceptions', async () => {\n      const now = Date.now();\n      let caughtException: ExceptionThrown;\n      const options: HtmlPdf.CreateOptions = {\n        port,\n        runtimeExceptionHandler: (event: ExceptionThrown) => { caughtException = event; },\n      };\n      const html = `\n        <html>\n          <body>\n            <script>\n              throw new Error('Oh no!');\n            </script>\n          </body>\n        </html>\n      `;\n      const result = await HtmlPdf.create(html, options);\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n      expect(caughtException).to.not.be.undefined;\n      expect(caughtException.timestamp).to.be.greaterThan(now);\n    });\n\n    it('should timeout', async () => {\n      const options: HtmlPdf.CreateOptions = {\n        port,\n        timeout: 0,\n      };\n      try {\n        await HtmlPdf.create('<p>hello!</p>', options);\n        expect.fail();\n      } catch (err) {\n        expect(err.message).to.equal('HtmlPdf.create() timed out.');\n      }\n    });\n\n    it('should fail to reach an invalid page', async () => {\n      const options: HtmlPdf.CreateOptions = {\n        port,\n      };\n      try {\n        const freePort = await getPort();\n        await HtmlPdf.create(`http://127.0.0.1:${freePort}`, options);\n        expect.fail();\n      } catch (err) {\n        expect(err.message).to.equal('HtmlPdf.create() page navigate failed.');\n      }\n    });\n\n    it('should generate a PDF with external JavaScript', async () => {\n      const html = `\n        <html>\n          <head>\n            <script src=\"https://code.jquery.com/jquery-3.2.1.slim.min.js\"></script>\n          </head>\n          <body>\n            <div id=\"test\">Failed!</div>\n            <script>\n              $('#test').text('Passed!');\n            </script>\n          </body>\n        </html>\n      `;\n      const result = await HtmlPdf.create(html, {port});\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n      const pdf = await getParsedPdf(result.toBuffer());\n      expect(pdf.getRawTextContent()).to.startWith('Passed!');\n    });\n\n    it('should generate a PDF with external CSS', async () => {\n      const css = \"#test:before{content:'Passed!'}\";\n      const html = `\n        <html>\n          <head>\n            <link rel=\"stylesheet\" href=\"data:text/css;charset=utf-8;base64,${Buffer.from(css).toString('base64')}\">\n          </head>\n          <body>\n            <div id=\"test\"></div>\n          </body>\n        </html>\n      `;\n      const result = await HtmlPdf.create(html, {port});\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n      const pdf = await getParsedPdf(result.toBuffer());\n      expect(pdf.getRawTextContent()).to.startWith('Passed!');\n    });\n\n    it('should generate a PDF with multiple pages', async () => {\n      const html = `\n        <html>\n          <body>\n            <div style=\"page-break-after:always\">Page 1</div>\n            <div>Page 2</div>\n          </body>\n        </html>\n      `;\n      const result = await HtmlPdf.create(html, {port});\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n      const pdf = await getParsedPdf(result.toBuffer());\n      expect(pdf.getRawTextContent()).to.contain('Page (0) Break').and.to.contain('Page (1) Break');\n    });\n\n    it('should generate a PDF with custom headers and footers', async () => {\n      const html = `\n        <html>\n          <head>\n            <title>TITLE</title>\n          </head>\n          <body>\n            <div style=\"page-break-after:always\">P1</div>\n            <div>P2</div>\n          </body>\n        </html>\n      `;\n      const result = await HtmlPdf.create(html, {\n        port,\n        printOptions: {\n          displayHeaderFooter: true,\n          headerTemplate: `\n            <div class=\"text center\" style=\"color:red;\">\n              Custom <b>header</b>!\n              Page <span class=\"pageNumber\"></span> of <span class=\"totalPages\"></span>.\n              Title: <span class=\"title\"></span>.\n            </div>\n          `,\n          footerTemplate: '<div class=\"text center\" style=\"color:green\">Custom <i>footer</i>!</div>',\n        },\n      });\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n      const pdf = await getParsedPdf(result.toBuffer());\n      const pdfText = pdf.getRawTextContent();\n      expect(pdfText).to.contain('Custom header!').and.to.contain('Custom footer!');\n      expect(pdfText).to.contain('Page 1 of 2.').and.to.contain('Page 2 of 2.');\n      expect(pdfText).to.contain('P1').and.to.contain('P2');\n      expect(pdfText).to.contain('Title: TITLE.');\n    });\n\n    it('should generate a PDF from a local file', async () => {\n      const filePath = path.join('file://', __dirname, '../../test/test.html');\n      const result = await HtmlPdf.create(filePath, {port});\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n      const pdf = await getParsedPdf(result.toBuffer());\n      expect(pdf.getRawTextContent()).to.startWith('Passed!');\n    });\n\n    it('should generate a PDF from an external site', async () => {\n      const result = await HtmlPdf.create('https://m.facebook.com/', {port});\n      expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n      const pdf = await getParsedPdf(result.toBuffer());\n      expect(pdf.getRawTextContent()).to.contain('Facebook');\n    });\n\n    describe('Http', async () => {\n\n      const baseOptions: HtmlPdf.CreateOptions = {\n        port,\n      };\n\n      const mockServer = require('mockttp').getLocal(); // {debug: true}\n      const mockServerPort = await getPort();\n      const mockUrl = `http://127.0.0.1:${mockServerPort}/mocked-path`;\n\n      before(() => {\n        mockServer.start(mockServerPort);\n      });\n      after(() => {\n        mockServer.stop();\n      });\n\n      it('should trigger loadingFailedHandler', (done) => {\n        const myOptions = Object.assign({}, baseOptions);\n        let alreadyReceivedLoadingFailedHandler = false;\n\n        myOptions.loadingFailedHandler = (e) => {\n          expect(e.requestId).to.not.be.null;\n          expect(e.timestamp).to.not.be.null;\n          expect(e.type).to.not.be.null;\n          alreadyReceivedLoadingFailedHandler = true;\n          done();\n        };\n\n        const html = `\n          <html>\n            <body>\n              <img src=\"http://thisdomaindoesnotexistforsureibelieveatleast.com/blah.png\">\n            </body>\n          </html>\n        `;\n\n        mockServer.get('/mocked-path')\n          .thenReply(200, html)\n          .then(async () => {\n\n            await HtmlPdf.create(mockUrl, myOptions).catch((err) => {\n              done(err);\n            }).then(() => {\n              if (!alreadyReceivedLoadingFailedHandler) {\n                done('Did not receive loadingFailedHandler call');\n              }\n            });\n\n          });\n\n      });\n\n      const statusCodeBasedTest = async (statusCodeToSend: number, expectFail: boolean, options: HtmlPdf.CreateOptions) => {\n\n        const myOptions = Object.assign({}, options);\n\n        const p = new Promise(async (resolve, reject) =>  {\n\n          mockServer.get('/mocked-path').thenReply(statusCodeToSend, 'A mocked response').then(async () => {\n            let alreadyFailed = false;\n\n            await HtmlPdf.create(mockUrl, myOptions).catch((err) => {\n              alreadyFailed = true;\n              if (!expectFail) {\n                reject(`Did not expect failure: ${err}`);\n              } else {\n                resolve();\n              }\n            }).then(() => {\n              if (alreadyFailed) {\n                return;\n              }\n              if (expectFail) {\n                reject(`create was supposed to fail but did not`);\n              } else {\n                resolve();\n              }\n            });\n\n          });\n\n        });\n\n        return p;\n      };\n\n      it('should fail on HTTP 4xx', (done) => {\n        statusCodeBasedTest(403, true, baseOptions)\n          .then(() => { done(); })\n          .catch((err) => { done(err); });\n      });\n\n      it('should fail on HTTP 5xx', (done) => {\n        statusCodeBasedTest(500, true, baseOptions)\n          .then(() => { done(); })\n          .catch((err) => { done(err); });\n      });\n\n      it('should NOT fail on HTTP 4xx if failOnHTTP5xx is false', (done) => {\n        baseOptions.failOnHTTP5xx = false;\n        statusCodeBasedTest(500, false, baseOptions)\n          .then(() => { done(); })\n          .catch((err) => { done(err); });\n      });\n\n      it('should NOT fail on HTTP 4xx if failOnHTTP4xx is false', (done) => {\n        baseOptions.failOnHTTP4xx = false;\n        statusCodeBasedTest(403, false, baseOptions)\n          .then(() => { done(); })\n          .catch((err) => { done(err); });\n      });\n\n      it('should trigger requestWillBeSentHandler', (done) => {\n        const myOptions = Object.assign({}, baseOptions);\n        let alreadyReceivedRequestWillBeSentHandler = false;\n        myOptions.requestWillBeSentHandler = (e) => {\n          expect(e.initiator).to.not.null;\n          expect(e.requestId).to.not.null;\n          expect(e.loaderId).to.not.null;\n          expect(e.timestamp).to.not.null;\n          expect(e.wallTime).to.not.null;\n          expect(e.request).to.not.null;\n          done();\n          alreadyReceivedRequestWillBeSentHandler = true;\n        };\n\n        mockServer.get('/mocked-path')\n          .thenReply(200, 'A mocked response')\n          .then(async () => {\n\n            await HtmlPdf.create(mockUrl, myOptions).catch((err) => {\n              done(err);\n            }).then(() => {\n              if (!alreadyReceivedRequestWillBeSentHandler) {\n                done('Did not receive requestWillBeSentHandler call');\n              }\n            });\n          });\n\n      });\n\n    });\n\n    describe('CompletionTrigger', () => {\n\n      const timeoutErrorMessage = 'CompletionTrigger timed out.';\n\n      describe('Timer', () => {\n\n        const html = `\n          <html>\n            <body>\n              <div id=\"test\">Failed!</div>\n              <script>\n                setTimeout(() => {\n                  document.getElementById('test').innerHTML = 'Passed!';\n                }, 200);\n              </script>\n            </body>\n          </html>\n        `;\n\n        it('should generate prematurely without a CompletionTrigger', async () => {\n          const result = await HtmlPdf.create(html, {port});\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Failed!');\n        });\n\n        it('should generate correctly after being triggered', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Timer(300),\n          };\n          const result = await HtmlPdf.create(html, options);\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Passed!');\n        });\n\n      });\n\n      describe('Event', () => {\n\n        const html = `\n          <html>\n            <body>\n              <div id=\"test\">Failed!</div>\n              <script>\n                setTimeout(() => {\n                  document.getElementById('test').innerHTML = 'Passed!';\n                  document.body.dispatchEvent(new Event('myEvent'));\n                }, 200);\n              </script>\n            </body>\n          </html>\n        `;\n\n        it('should generate prematurely without a CompletionTrigger', async () => {\n          const result = await HtmlPdf.create(html, {port});\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Failed!');\n        });\n\n        it('should time out', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Event('myEvent', null, 1),\n          };\n          try {\n            await HtmlPdf.create(html, options);\n            expect.fail();\n          } catch (err) {\n            expect(err.message).to.equal(timeoutErrorMessage);\n          }\n        });\n\n        it('should time out from listening to the wrong event', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Event('myEvent', '#test', 300),\n          };\n          try {\n            await HtmlPdf.create(html, options);\n            expect.fail();\n          } catch (err) {\n            expect(err.message).to.equal(timeoutErrorMessage);\n          }\n        });\n\n        it('should generate correctly after being triggered', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Event('myEvent'),\n          };\n          const result = await HtmlPdf.create(html, options);\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Passed!');\n        });\n\n      });\n\n      describe('Callback', () => {\n\n        const html = `\n          <html>\n            <body>\n              <div id=\"test\">Failed!</div>\n              <script>\n                setTimeout(() => {\n                  document.getElementById('test').innerHTML = 'Timeout!';\n                  if (window.htmlPdfCb) {\n                    document.getElementById('test').innerHTML = 'Callback!';\n                    htmlPdfCb();\n                  }\n                }, 200);\n              </script>\n            </body>\n          </html>\n        `;\n\n        it('should generate prematurely without a CompletionTrigger', async () => {\n          const result = await HtmlPdf.create(html, {port});\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Failed!');\n        });\n\n        it('should time out', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Callback(null, 1),\n          };\n          try {\n            await HtmlPdf.create(html, options);\n            expect.fail();\n          } catch (err) {\n            expect(err.message).to.equal(timeoutErrorMessage);\n          }\n        });\n\n        it('should time out from listening to the wrong callback', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Callback('wrongCb', 300),\n          };\n          try {\n            await HtmlPdf.create(html, options);\n            expect.fail();\n          } catch (err) {\n            expect(err.message).to.equal(timeoutErrorMessage);\n          }\n        });\n\n        it('should generate correctly after being triggered', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Callback(),\n          };\n          const result = await HtmlPdf.create(html, options);\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Callback!');\n        });\n\n      });\n\n      describe('Element', () => {\n\n        const html = `\n          <html>\n            <body>\n              <div id=\"test\">Failed!</div>\n              <script>\n                setTimeout(() => {\n                  const inserted = document.createElement('div');\n                  inserted.id = 'inserted';\n                  inserted.innerText = 'Passed!';\n                  document.body.insertBefore(inserted, document.getElementById('test'));\n                }, 200);\n              </script>\n            </body>\n          </html>\n        `;\n\n        it('should generate prematurely without a CompletionTrigger', async () => {\n          const result = await HtmlPdf.create(html, {port});\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Failed!');\n        });\n\n        it('should time out', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Element('div#inserted', 1),\n          };\n          try {\n            await HtmlPdf.create(html, options);\n            expect.fail();\n          } catch (err) {\n            expect(err.message).to.equal(timeoutErrorMessage);\n          }\n        });\n\n        it('should time out from listening for the wrong element', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Element('div#derp', 300),\n          };\n          try {\n            await HtmlPdf.create(html, options);\n            expect.fail();\n          } catch (err) {\n            expect(err.message).to.equal(timeoutErrorMessage);\n          }\n        });\n\n        it('should generate correctly after being triggered', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Element('div#inserted'),\n          };\n          const result = await HtmlPdf.create(html, options);\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Passed!');\n        });\n\n      });\n\n      describe('Variable', () => {\n\n        const html = `\n          <html>\n            <body>\n              <div id=\"test\">Failed!</div>\n              <script>\n                setTimeout(() => {\n                  document.getElementById('test').innerHTML = 'Variable!';\n                  htmlPdfDone = true;\n                }, 200);\n              </script>\n            </body>\n          </html>\n        `;\n\n        it('should generate prematurely without a CompletionTrigger', async () => {\n          const result = await HtmlPdf.create(html, {port});\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Failed!');\n        });\n\n        it('should time out', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Variable(null, 1),\n          };\n          try {\n            await HtmlPdf.create(html, options);\n            expect.fail();\n          } catch (err) {\n            expect(err.message).to.equal(timeoutErrorMessage);\n          }\n        });\n\n        it('should time out from listening to the wrong variable', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Variable('wrongVar', 300),\n          };\n          try {\n            await HtmlPdf.create(html, options);\n            expect.fail();\n          } catch (err) {\n            expect(err.message).to.equal(timeoutErrorMessage);\n          }\n        });\n\n        it('should generate correctly after being triggered', async () => {\n          const options: HtmlPdf.CreateOptions = {\n            port,\n            completionTrigger: new HtmlPdf.CompletionTrigger.Variable(),\n          };\n          const result = await HtmlPdf.create(html, options);\n          expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n          const pdf = await getParsedPdf(result.toBuffer());\n          expect(pdf.getRawTextContent()).startsWith('Variable!');\n        });\n\n      });\n\n    });\n\n    describe('Concurrent PDF generation', function() {\n      this.timeout(25000);\n      async function createAndParse(index: string): Promise<string> {\n        const html = `<p>${index}</p>`;\n        const result = await HtmlPdf.create(html, { port });\n        const parsed = await getParsedPdf(result.toBuffer());\n        const regex = /^(\\d+)\\r\\n----------------Page \\(0\\) Break----------------\\r\\n$/;\n        return (regex.exec(parsed.getRawTextContent()) || [])[1];\n      }\n\n      const length = 10;\n      it(`should concurrently generate ${length} PDFs`, async () => {\n        const input = Array.from({length}, (_, i) => `${i}`);\n        const results = await Promise.all(input.map(createAndParse));\n        expect(results).to.deep.equal(input);\n      });\n    });\n\n  });\n\n  describe('CreateResult', () => {\n\n    const testBase64 = Buffer.from('test').toString('base64');\n\n    describe('constructor', () => {\n      it('should instanciate', () => {\n        const result = new HtmlPdf.CreateResult('');\n        expect(result).to.be.an.instanceOf(HtmlPdf.CreateResult);\n      });\n    });\n\n    describe('toBase64', () => {\n      it('should output a base64 string', () => {\n        const cr = new HtmlPdf.CreateResult(testBase64);\n        expect(cr.toBase64()).to.equal(testBase64);\n      });\n    });\n\n    describe('toBuffer', () => {\n      it('should output a Buffer', () => {\n        const cr = new HtmlPdf.CreateResult(testBase64);\n        expect(cr.toBuffer()).to.deep.equal(Buffer.from('test'));\n      });\n    });\n\n    describe('toStream', () => {\n      it('should output a Readable Stream', () => {\n        const cr = new HtmlPdf.CreateResult(testBase64);\n        const stream = cr.toStream();\n        expect(stream).to.be.an.instanceOf(Readable);\n      });\n\n      it('should output a valid Stream', (done) => {\n        const cr = new HtmlPdf.CreateResult(testBase64);\n        const stream = cr.toStream();\n        let bytes = Buffer.from('');\n        stream.on('data', (chunk) => {\n          bytes = Buffer.concat([bytes, chunk]);\n        });\n        stream.on('end', () => {\n          try {\n            expect(bytes).to.deep.equal(cr.toBuffer());\n            done();\n          } catch (err) {\n            done(err);\n          }\n        });\n      });\n    });\n\n    describe('toFile', () => {\n      it('should output a file', async () => {\n        try {\n          mockFs({\n            myDir: {},\n          });\n          const cr = new HtmlPdf.CreateResult(testBase64);\n          const filePath = 'myDir/file.pdf';\n          await cr.toFile(filePath);\n          const stats = fs.statSync(filePath);\n          expect(stats.isFile()).to.be.true;\n          expect(stats.isDirectory()).to.be.false;\n          expect(stats.size).to.be.greaterThan(0);\n        } finally {\n          mockFs.restore();\n        }\n      });\n\n      it('should fail output to a nonexistent directory', async () => {\n        try {\n          mockFs();\n          const cr = new HtmlPdf.CreateResult(testBase64);\n          await cr.toFile('myDir/file.pdf');\n          expect.fail();\n        } catch (err) {\n          expect(err.message).to.contain('no such file or directory');\n        } finally {\n          mockFs.restore();\n        }\n      });\n    });\n\n  });\n\n});\n\nasync function getParsedPdf(buffer: Buffer): Promise<any> {\n  return new Promise((resolve, reject) => {\n    const pdfParser = new PDFParser(null, 1);\n    pdfParser.on('pdfParser_dataError', (err) => reject(err.parserError));\n    pdfParser.on('pdfParser_dataReady', () => resolve(pdfParser));\n    pdfParser.parseBuffer(buffer);\n  });\n}\n"],"sourceRoot":"../.."}